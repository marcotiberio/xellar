import "./chunk-RSJERJUL.js";

// node_modules/@webreflection/custom-elements-attributes/esm/index.js
var esm_default = (whenDefined2, MutationObserver4) => {
  const attributeChanged = (records) => {
    for (let i = 0, { length } = records; i < length; i++)
      dispatch(records[i]);
  };
  const dispatch = ({ target, attributeName, oldValue }) => {
    target.attributeChangedCallback(
      attributeName,
      oldValue,
      target.getAttribute(attributeName)
    );
  };
  return (target, is) => {
    const { observedAttributes: attributeFilter } = target.constructor;
    if (attributeFilter) {
      whenDefined2(is).then(() => {
        new MutationObserver4(attributeChanged).observe(target, {
          attributes: true,
          attributeOldValue: true,
          attributeFilter
        });
        for (let i = 0, { length } = attributeFilter; i < length; i++) {
          if (target.hasAttribute(attributeFilter[i]))
            dispatch({ target, attributeName: attributeFilter[i], oldValue: null });
        }
      });
    }
    return target;
  };
};

// node_modules/@webreflection/custom-elements-upgrade/esm/index.js
var { keys } = Object;
var expando = (element) => {
  const key = keys(element);
  const value = [];
  const { length } = key;
  for (let i = 0; i < length; i++) {
    value[i] = element[key[i]];
    delete element[key[i]];
  }
  return () => {
    for (let i = 0; i < length; i++)
      element[key[i]] = value[i];
  };
};

// node_modules/element-notifier/esm/index.js
var TRUE = true;
var FALSE = false;
var QSA = "querySelectorAll";
var notify = (callback, root = document, MO = MutationObserver, query2 = ["*"]) => {
  const loop = (nodes, selectors, added, removed, connected, pass) => {
    for (const node of nodes) {
      if (pass || QSA in node) {
        if (connected) {
          if (!added.has(node)) {
            added.add(node);
            removed.delete(node);
            callback(node, connected);
          }
        } else if (!removed.has(node)) {
          removed.add(node);
          added.delete(node);
          callback(node, connected);
        }
        if (!pass)
          loop(node[QSA](selectors), selectors, added, removed, connected, TRUE);
      }
    }
  };
  const mo = new MO((records) => {
    if (query2.length) {
      const selectors = query2.join(",");
      const added = /* @__PURE__ */ new Set(), removed = /* @__PURE__ */ new Set();
      for (const { addedNodes, removedNodes } of records) {
        loop(removedNodes, selectors, added, removed, FALSE, FALSE);
        loop(addedNodes, selectors, added, removed, TRUE, FALSE);
      }
    }
  });
  const { observe } = mo;
  (mo.observe = (node) => observe.call(mo, node, { subtree: TRUE, childList: TRUE }))(root);
  return mo;
};

// node_modules/qsa-observer/esm/index.js
var QSA2 = "querySelectorAll";
var { document: document2, Element, MutationObserver: MutationObserver2, Set: Set2, WeakMap } = self;
var elements = (element) => QSA2 in element;
var { filter } = [];
var esm_default2 = (options) => {
  const live = new WeakMap();
  const drop = (elements2) => {
    for (let i = 0, { length } = elements2; i < length; i++)
      live.delete(elements2[i]);
  };
  const flush = () => {
    const records = observer.takeRecords();
    for (let i = 0, { length } = records; i < length; i++) {
      parse2(filter.call(records[i].removedNodes, elements), false);
      parse2(filter.call(records[i].addedNodes, elements), true);
    }
  };
  const matches = (element) => element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
  const notifier = (element, connected) => {
    let selectors;
    if (connected) {
      for (let q, m = matches(element), i = 0, { length } = query2; i < length; i++) {
        if (m.call(element, q = query2[i])) {
          if (!live.has(element))
            live.set(element, new Set2());
          selectors = live.get(element);
          if (!selectors.has(q)) {
            selectors.add(q);
            options.handle(element, connected, q);
          }
        }
      }
    } else if (live.has(element)) {
      selectors = live.get(element);
      live.delete(element);
      selectors.forEach((q) => {
        options.handle(element, connected, q);
      });
    }
  };
  const parse2 = (elements2, connected = true) => {
    for (let i = 0, { length } = elements2; i < length; i++)
      notifier(elements2[i], connected);
  };
  const { query: query2 } = options;
  const root = options.root || document2;
  const observer = notify(notifier, root, MutationObserver2, query2);
  const { attachShadow: attachShadow2 } = Element.prototype;
  if (attachShadow2)
    Element.prototype.attachShadow = function(init) {
      const shadowRoot = attachShadow2.call(this, init);
      observer.observe(shadowRoot);
      return shadowRoot;
    };
  if (query2.length)
    parse2(root[QSA2](query2));
  return { drop, flush, observer, parse: parse2 };
};

// node_modules/@webreflection/custom-elements-builtin/esm/index.js
var {
  customElements,
  document: document3,
  Element: Element2,
  MutationObserver: MutationObserver3,
  Object: Object2,
  Promise: Promise2,
  Map,
  Set: Set3,
  WeakMap: WeakMap2,
  Reflect
} = self;
var { createElement } = document3;
var { define, get, upgrade } = customElements;
var { construct } = Reflect || { construct(HTMLElement) {
  return HTMLElement.call(this);
} };
var { defineProperty, getOwnPropertyNames, setPrototypeOf } = Object2;
var shadowRoots = new WeakMap2();
var shadows = new Set3();
var classes = new Map();
var defined = new Map();
var prototypes = new Map();
var registry = new Map();
var shadowed = [];
var query = [];
var getCE = (is) => registry.get(is) || get.call(customElements, is);
var handle = (element, connected, selector) => {
  const proto = prototypes.get(selector);
  if (connected && !proto.isPrototypeOf(element)) {
    const redefine = expando(element);
    override = setPrototypeOf(element, proto);
    try {
      new proto.constructor();
    } finally {
      override = null;
      redefine();
    }
  }
  const method = `${connected ? "" : "dis"}connectedCallback`;
  if (method in proto)
    element[method]();
};
var { parse } = esm_default2({ query, handle });
var { parse: parseShadowed } = esm_default2({
  query: shadowed,
  handle(element, connected) {
    if (shadowRoots.has(element)) {
      if (connected)
        shadows.add(element);
      else
        shadows.delete(element);
      if (query.length)
        parseShadow.call(query, element);
    }
  }
});
var { attachShadow } = Element2.prototype;
if (attachShadow)
  Element2.prototype.attachShadow = function(init) {
    const root = attachShadow.call(this, init);
    shadowRoots.set(this, root);
    return root;
  };
var whenDefined = (name) => {
  if (!defined.has(name)) {
    let _, $ = new Promise2(($2) => {
      _ = $2;
    });
    defined.set(name, { $, _ });
  }
  return defined.get(name).$;
};
var augment = esm_default(whenDefined, MutationObserver3);
var override = null;
getOwnPropertyNames(self).filter((k) => /^HTML.*Element$/.test(k)).forEach((k) => {
  const HTMLElement = self[k];
  function HTMLBuiltIn() {
    const { constructor } = this;
    if (!classes.has(constructor))
      throw new TypeError("Illegal constructor");
    const { is, tag } = classes.get(constructor);
    if (is) {
      if (override)
        return augment(override, is);
      const element = createElement.call(document3, tag);
      element.setAttribute("is", is);
      return augment(setPrototypeOf(element, constructor.prototype), is);
    } else
      return construct.call(this, HTMLElement, [], constructor);
  }
  setPrototypeOf(HTMLBuiltIn, HTMLElement);
  defineProperty(
    HTMLBuiltIn.prototype = HTMLElement.prototype,
    "constructor",
    { value: HTMLBuiltIn }
  );
  defineProperty(self, k, { value: HTMLBuiltIn });
});
defineProperty(document3, "createElement", {
  configurable: true,
  value(name, options) {
    const is = options && options.is;
    if (is) {
      const Class = registry.get(is);
      if (Class && classes.get(Class).tag === name)
        return new Class();
    }
    const element = createElement.call(document3, name);
    if (is)
      element.setAttribute("is", is);
    return element;
  }
});
defineProperty(customElements, "get", {
  configurable: true,
  value: getCE
});
defineProperty(customElements, "whenDefined", {
  configurable: true,
  value: whenDefined
});
defineProperty(customElements, "upgrade", {
  configurable: true,
  value(element) {
    const is = element.getAttribute("is");
    if (is) {
      const constructor = registry.get(is);
      if (constructor) {
        augment(setPrototypeOf(element, constructor.prototype), is);
        return;
      }
    }
    upgrade.call(customElements, element);
  }
});
defineProperty(customElements, "define", {
  configurable: true,
  value(is, Class, options) {
    if (getCE(is))
      throw new Error(`'${is}' has already been defined as a custom element`);
    let selector;
    const tag = options && options.extends;
    classes.set(Class, tag ? { is, tag } : { is: "", tag: is });
    if (tag) {
      selector = `${tag}[is="${is}"]`;
      prototypes.set(selector, Class.prototype);
      registry.set(is, Class);
      query.push(selector);
    } else {
      define.apply(customElements, arguments);
      shadowed.push(selector = is);
    }
    whenDefined(is).then(() => {
      if (tag) {
        parse(document3.querySelectorAll(selector));
        shadows.forEach(parseShadow, [selector]);
      } else
        parseShadowed(document3.querySelectorAll(selector));
    });
    defined.get(is)._(Class);
  }
});
function parseShadow(element) {
  const root = shadowRoots.get(element);
  parse(root.querySelectorAll(this), element.isConnected);
}
/*! Bundled license information:

element-notifier/esm/index.js:
  (*! (c) Andrea Giammarchi - ISC *)
*/
//# sourceMappingURL=@webreflection_custom-elements-builtin.js.map
